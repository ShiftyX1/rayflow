<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Авторитетная симуляция — Архитектурная спецификация</title>
  <style>
    :root { color-scheme: light dark; }
    body { font: 14px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; max-width: 1050px; }
    h1, h2, h3 { line-height: 1.2; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { padding: 12px; border: 1px solid #8884; border-radius: 8px; overflow: auto; }
    table { border-collapse: collapse; width: 100%; margin: 10px 0 18px; }
    th, td { border: 1px solid #8884; padding: 8px; vertical-align: top; }
    th { text-align: left; }
    .muted { opacity: 0.85; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #8884; border-radius: 999px; font-size: 12px; }
    .highlight { background: #ffc; padding: 2px 4px; border-radius: 3px; }
    ul { margin-top: 6px; }
    .rule { border-left: 3px solid #0084; padding-left: 12px; margin: 12px 0; }
  </style>
</head>
<body>
  <h1>Авторитетная симуляция — Архитектурная спецификация</h1>
  <p class="muted">
    Проект: rayflow (воксельная игра в стиле BedWars). Документ определяет, что означает "авторитетная симуляция"
    в контексте этого проекта, и устанавливает архитектурные границы между сервером и клиентом.
  </p>

  <h2>1. Основной принцип</h2>
  <p>
    <strong>Авторитетная симуляция</strong> означает, что <span class="highlight">сервер является единственным источником истины</span>
    для всего игрового состояния, применения правил и логики симуляции. Клиент — это <span class="highlight">тонкий слой представления</span>,
    который рендерит игровое состояние и захватывает ввод пользователя, но никогда напрямую не изменяет и не симулирует авторитетное состояние игры.
  </p>

  <h2>2. Обязанности сервера</h2>
  <p>Сервер имеет исключительные полномочия над:</p>

  <h3>2.1 Симуляция и физика</h3>
  <ul>
    <li><strong>Фиксированный цикл тиков:</strong> Сервер работает с фиксированной частотой тиков (по умолчанию 30 TPS) с детерминированным временным шагом.</li>
    <li><strong>Движение игроков:</strong> Сервер выполняет все физические расчёты, включая гравитацию, прыжки, обнаружение столкновений с воксельными блоками.</li>
    <li><strong>Состояние сущностей:</strong> Все позиции, скорости, здоровье и статусные эффекты сущностей вычисляются на стороне сервера.</li>
  </ul>

  <h3>2.2 Правила и валидация</h3>
  <ul>
    <li><strong>Проверка команд:</strong> Сервер проверяет каждую команду клиента перед выполнением (например, может ли игрок сломать этот блок?).</li>
    <li><strong>Игровые правила:</strong> Тайминг матча, условия победы, командная механика, генерация ресурсов — всё это применяется на сервере.</li>
    <li><strong>Предотвращение читов:</strong> Ограничения скорости движения, дальность действия, время восстановления действий — всё это проверяется сервером.</li>
  </ul>

  <h3>2.3 Состояние мира</h3>
  <ul>
    <li><strong>Изменения блоков:</strong> Установка и разрушение блоков проверяется и выполняется на сервере.</li>
    <li><strong>Защита шаблона:</strong> Сервер контролирует, какие блоки можно изменять, на основе метаданных шаблона карты.</li>
    <li><strong>Границы мира:</strong> Сервер применяет ограничения мира и предотвращает выход за пределы.</li>
  </ul>

  <h3>2.4 Жизненный цикл матча</h3>
  <ul>
    <li><strong>Инициализация матча:</strong> Сервер загружает шаблоны карт и инициализирует состояние матча.</li>
    <li><strong>Спавн игроков:</strong> Сервер определяет точки появления и управляет возрождением.</li>
    <li><strong>Перезапуск матча:</strong> Сервер переинициализирует карты из шаблонов.</li>
  </ul>

  <h2>3. Обязанности клиента</h2>
  <p>Клиент строго ограничен представлением и захватом ввода:</p>

  <h3>3.1 Рендеринг</h3>
  <ul>
    <li><strong>Визуальное представление:</strong> Рендеринг блоков, сущностей, эффектов на основе состояния, предоставленного сервером.</li>
    <li><strong>Интерполяция:</strong> Плавная интерполяция между снимками состояния сервера для плавного рендеринга.</li>
    <li><strong>Камера и область просмотра:</strong> Управление позицией камеры и перспективой рендеринга (не влияет на симуляцию).</li>
    <li><strong>Визуальные настройки:</strong> Скайбокс, освещение, цвета листвы в зависимости от температуры (из секции <code>VIS0</code> карты).</li>
  </ul>

  <h3>3.2 Пользовательский интерфейс</h3>
  <ul>
    <li><strong>Рендеринг HUD:</strong> Отображение полосок здоровья, инвентаря, таймера матча на основе данных, предоставленных сервером.</li>
    <li><strong>Отладочный UI:</strong> Оверлеи для разработчиков для отладки (не влияют на симуляцию).</li>
    <li><strong>Оверлей разрушения блока:</strong> Визуальная обратная связь о прогрессе разрушения блока (фактическое разрушение происходит на сервере).</li>
  </ul>

  <h3>3.3 Захват ввода</h3>
  <ul>
    <li><strong>Фреймы намерений:</strong> Клиент захватывает ввод с клавиатуры/мыши и отправляет <em>намерение</em> на сервер.</li>
    <li><strong>Без прямого выполнения:</strong> Клиент не выполняет игровую логику; он только запрашивает действия.</li>
    <li><strong>Рейкастинг для выбора цели:</strong> Клиент выполняет рейкастинг для определения <em>того</em>, с чем игрок хочет взаимодействовать, но сервер проверяет это.</li>
  </ul>

  <h2>4. Архитектурные границы</h2>

  <div class="rule">
    <strong>Правило 1: Нет общей мутации состояния</strong><br>
    Клиент никогда не должен напрямую читать из структур состояния сервера или писать в них. Коммуникация происходит исключительно через протокольный слой.
  </div>

  <div class="rule">
    <strong>Правило 2: Состояние клиента — это реплика</strong><br>
    Любое игровое состояние на клиенте (позиции игроков, состояние блоков) — это <em>реплика</em>, восстановленная из сообщений сервера. Если клиент и сервер расходятся, состояние сервера всегда верное.
  </div>

  <div class="rule">
    <strong>Правило 3: Сервер проверяет всё</strong><br>
    Сервер никогда не должен доверять значениям, предоставленным клиентом, для критичных для симуляции данных (позиции, временные метки, количество ресурсов). Клиент отправляет <em>намерения</em>, сервер вычисляет результаты.
  </div>

  <div class="rule">
    <strong>Правило 4: Визуальные настройки не влияют на симуляцию</strong><br>
    Параметры рендеринга (скайбокс, время суток, температура листвы) — это вопросы только клиента, загружаемые из метаданных карты (секция <code>VIS0</code>). Они не должны влиять на коллизии, движение или игровые правила.
  </div>

  <h2>5. Что это означает на практике</h2>

  <h3>5.1 Движение игрока</h3>
  <table>
    <tr><th>Компонент</th><th>Авторитет</th><th>Детали</th></tr>
    <tr>
      <td>Захват ввода</td>
      <td>Клиент</td>
      <td>Клиент обнаруживает нажатия клавиш (W/A/S/D/Пробел) и отправляет фреймы намерений на сервер.</td>
    </tr>
    <tr>
      <td>Физическая симуляция</td>
      <td>Сервер</td>
      <td>Сервер применяет скорость, гравитацию, обнаружение столкновений с блоками, обновляет позицию.</td>
    </tr>
    <tr>
      <td>Рендеринг позиции</td>
      <td>Клиент</td>
      <td>Клиент интерполирует между снимками сервера и рендерит игрока в плавной позиции.</td>
    </tr>
  </table>

  <h3>5.2 Разрушение блока</h3>
  <table>
    <tr><th>Компонент</th><th>Авторитет</th><th>Детали</th></tr>
    <tr>
      <td>Выбор цели</td>
      <td>Клиент</td>
      <td>Клиент выполняет рейкастинг для определения, на какой блок смотрит игрок.</td>
    </tr>
    <tr>
      <td>Проверка разрушения</td>
      <td>Сервер</td>
      <td>Сервер проверяет: дальность действия, правила защиты блоков, разрешения игрока.</td>
    </tr>
    <tr>
      <td>Удаление блока</td>
      <td>Сервер</td>
      <td>Сервер удаляет блок из состояния мира и рассылает обновление.</td>
    </tr>
    <tr>
      <td>Визуальная обратная связь</td>
      <td>Клиент</td>
      <td>Клиент показывает анимацию оверлея разрушения; сервер отслеживает фактический прогресс разрушения.</td>
    </tr>
  </table>

  <h3>5.3 Временный террейн (помощь при миграции)</h3>
  <p class="muted">
    В настоящее время проект использует процедурный террейн на основе seed в качестве <strong>временной помощи при миграции</strong>:
  </p>
  <ul>
    <li>Сервер выбирает <code>worldSeed</code> и отправляет его клиентам в <code>ServerHello</code>.</li>
    <li>Клиент использует тот же seed для генерации соответствующего террейна для рендеринга.</li>
    <li>Сервер выполняет обнаружение столкновений с тем же террейном, сгенерированным из seed.</li>
    <li><strong>Важно:</strong> Это НЕ финальный дизайн. Финальные карты BedWars будут загружаться из шаблонов <code>.rfmap</code>.</li>
  </ul>

  <h2>6. Будущее: Предсказание и компенсация задержки</h2>
  <p>
    Текущая архитектура намеренно <strong>не включает</strong> предсказание на стороне клиента или компенсацию задержки.
    Эти функции запланированы для <span class="pill">Этапа C</span> плана миграции.
  </p>

  <p>При реализации предсказание будет работать следующим образом:</p>
  <ul>
    <li><strong>Предсказание клиента:</strong> Клиент может запускать <em>спекулятивную</em> копию физики движения локально для немедленной визуальной обратной связи.</li>
    <li><strong>Согласование с сервером:</strong> Когда приходит состояние сервера, клиент отбрасывает предсказание и переходит к авторитетной позиции.</li>
    <li><strong>По-прежнему авторитетно:</strong> Состояние сервера всегда побеждает; предсказание чисто косметическое, чтобы скрыть задержку.</li>
  </ul>

  <h2>7. Единый протокол для онлайн и офлайн режимов</h2>
  <p>
    Проект использует <strong>ту же авторитетную архитектуру</strong> как для "одиночной игры", так и для многопользовательской:
  </p>
  <ul>
    <li><strong>Одиночная игра:</strong> Экземпляр сервера работает локально, клиент подключается через <code>LocalTransport</code> (в памяти).</li>
    <li><strong>Многопользовательская игра:</strong> Сервер работает удалённо, клиент подключается через сетевой транспорт.</li>
    <li><strong>Без специальной офлайн логики:</strong> Все правила, валидация и симуляция проходят через сервер даже в одиночной игре.</li>
  </ul>

  <h2>8. Логирование и отладка</h2>
  <p>Для поддерживаемости авторитетной симуляции сервер должен логировать:</p>
  <ul>
    <li><strong>Полученная команда:</strong> Какое действие запросил клиент?</li>
    <li><strong>Результат валидации:</strong> Было ли оно разрешено или отклонено? Почему?</li>
    <li><strong>Изменение состояния:</strong> Какое состояние симуляции было изменено?</li>
  </ul>
  <p class="muted">
    Логирование должно быть ограничено по частоте, чтобы избежать спама (например, не логировать каждый тик, только переходы состояний).
  </p>

  <hr />
  <p class="muted">
    Документ отражает текущую архитектуру по состоянию на декабрь 2025 года.
  </p>
</body>
</html>
